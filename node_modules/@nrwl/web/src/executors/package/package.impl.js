"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRollupOptions = void 0;
const tslib_1 = require("tslib");
const rollup = require("rollup");
const peerDepsExternal = require("rollup-plugin-peer-deps-external");
const plugin_babel_1 = require("@rollup/plugin-babel");
const path_1 = require("path");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const rxjs_for_await_1 = require("rxjs-for-await");
const autoprefixer = require("autoprefixer");
const devkit_1 = require("@nrwl/devkit");
const project_graph_1 = require("@nrwl/workspace/src/core/project-graph");
const buildable_libs_utils_1 = require("@nrwl/workspace/src/utilities/buildable-libs-utils");
const plugin_node_resolve_1 = require("@rollup/plugin-node-resolve");
const delete_output_dir_1 = require("../../utils/delete-output-dir");
const run_rollup_1 = require("./lib/run-rollup");
const normalize_1 = require("./lib/normalize");
// These use require because the ES import isn't correct.
const commonjs = require('@rollup/plugin-commonjs');
const typescript = require('rollup-plugin-typescript2');
const image = require('@rollup/plugin-image');
const json = require('@rollup/plugin-json');
const copy = require('rollup-plugin-copy');
const postcss = require('rollup-plugin-postcss');
const filesize = require('rollup-plugin-filesize');
const fileExtensions = ['.js', '.jsx', '.ts', '.tsx'];
function run(rawOptions, context) {
    var _a;
    return tslib_1.__asyncGenerator(this, arguments, function* run_1() {
        const project = context.workspace.projects[context.projectName];
        const projectGraph = project_graph_1.readCachedProjectGraph('4.0');
        const sourceRoot = project.sourceRoot;
        const { target, dependencies } = buildable_libs_utils_1.calculateProjectDependencies(projectGraph, context.root, context.projectName, context.targetName, context.configurationName);
        if (!buildable_libs_utils_1.checkDependentProjectsHaveBeenBuilt(context.root, context.projectName, context.targetName, dependencies)) {
            throw new Error();
        }
        if (rawOptions.babelConfig) {
            devkit_1.logger.warn(`Deprecated option "babelConfig" used, please use the .babelrc file for ${context.projectName} instead.`);
        }
        const options = normalize_1.normalizePackageOptions(rawOptions, context.root, sourceRoot);
        const packageJson = devkit_1.readJsonFile(options.project);
        const npmDeps = ((_a = projectGraph.dependencies[context.projectName]) !== null && _a !== void 0 ? _a : [])
            .filter((d) => d.target.startsWith('npm:'))
            .map((d) => d.target.substr(4));
        const rollupOptions = createRollupOptions(options, dependencies, context, packageJson, sourceRoot, npmDeps);
        if (options.watch) {
            const watcher = rollup.watch(rollupOptions);
            return yield tslib_1.__await(yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(rxjs_for_await_1.eachValueFrom(new rxjs_1.Observable((obs) => {
                watcher.on('event', (data) => {
                    if (data.code === 'START') {
                        devkit_1.logger.info(`Bundling ${context.projectName}...`);
                    }
                    else if (data.code === 'END') {
                        updatePackageJson(options, context, target, dependencies, packageJson);
                        devkit_1.logger.info('Bundle complete. Watching for file changes...');
                        obs.next({ success: true });
                    }
                    else if (data.code === 'ERROR') {
                        devkit_1.logger.error(`Error during bundle: ${data.error.message}`);
                        obs.next({ success: false });
                    }
                });
                // Teardown logic. Close watcher when unsubscribed.
                return () => watcher.close();
            }))))));
        }
        else {
            devkit_1.logger.info(`Bundling ${context.projectName}...`);
            // Delete output path before bundling
            if (options.deleteOutputPath) {
                delete_output_dir_1.deleteOutputDir(context.root, options.outputPath);
            }
            return yield tslib_1.__await(rxjs_1.from(rollupOptions)
                .pipe(operators_1.concatMap((opts) => run_rollup_1.runRollup(opts).pipe(operators_1.catchError((e) => {
                devkit_1.logger.error(`Error during bundle: ${e}`);
                return rxjs_1.of({ success: false });
            }), operators_1.last(), operators_1.tap({
                next: (result) => {
                    if (result.success) {
                        updatePackageJson(options, context, target, dependencies, packageJson);
                        devkit_1.logger.info(`Bundle complete: ${context.projectName}`);
                    }
                    else {
                        devkit_1.logger.error(`Bundle failed: ${context.projectName}`);
                    }
                },
            }))))
                .toPromise());
        }
    });
}
exports.default = run;
// -----------------------------------------------------------------------------
function createRollupOptions(options, dependencies, context, packageJson, sourceRoot, npmDeps) {
    return options.format.map((format) => {
        const plugins = [
            copy({
                targets: convertCopyAssetsToRollupOptions(options.outputPath, options.assets),
            }),
            image(),
            typescript({
                check: true,
                tsconfig: options.tsConfig,
                tsconfigOverride: {
                    compilerOptions: createCompilerOptions(format, options, dependencies),
                },
            }),
            peerDepsExternal({
                packageJsonPath: options.project,
            }),
            postcss({
                inject: true,
                extract: options.extractCss,
                autoModules: true,
                plugins: [autoprefixer],
            }),
            plugin_node_resolve_1.default({
                preferBuiltins: true,
                extensions: fileExtensions,
            }),
            plugin_babel_1.getBabelInputPlugin({
                // Let's `@nrwl/web/babel` preset know that we are packaging.
                caller: {
                    // Ignored since this is for our custom babel-loader + babel preset
                    // @ts-ignore
                    isNxPackage: true,
                },
                cwd: path_1.join(context.root, sourceRoot),
                rootMode: 'upward',
                babelrc: true,
                extensions: fileExtensions,
                babelHelpers: 'bundled',
                exclude: /node_modules/,
                plugins: [
                    format === 'esm'
                        ? undefined
                        : require.resolve('babel-plugin-transform-async-to-promises'),
                ].filter(Boolean),
            }),
            commonjs(),
            filesize(),
            json(),
        ];
        const globals = options.globals
            ? options.globals.reduce((acc, item) => {
                acc[item.moduleId] = item.global;
                return acc;
            }, { 'react/jsx-runtime': 'jsxRuntime' })
            : { 'react/jsx-runtime': 'jsxRuntime' };
        const externalPackages = dependencies
            .map((d) => d.name)
            .concat(options.external || [])
            .concat(Object.keys(packageJson.dependencies || {}));
        const rollupConfig = {
            input: options.entryFile,
            output: {
                globals,
                format,
                file: `${options.outputPath}/${context.projectName}.${format}.js`,
                name: options.umdName || devkit_1.names(context.projectName).className,
            },
            external: (id) => externalPackages.some((name) => id === name || id.startsWith(`${name}/`)) || npmDeps.some((name) => id === name || id.startsWith(`${name}/`)),
            plugins,
        };
        return options.rollupConfig.reduce((currentConfig, plugin) => {
            return require(plugin)(currentConfig, options);
        }, rollupConfig);
    });
}
exports.createRollupOptions = createRollupOptions;
function createCompilerOptions(format, options, dependencies) {
    const compilerOptionPaths = buildable_libs_utils_1.computeCompilerOptionsPaths(options.tsConfig, dependencies);
    const compilerOptions = {
        rootDir: options.entryRoot,
        allowJs: false,
        declaration: true,
        paths: compilerOptionPaths,
    };
    if (format !== 'esm') {
        return Object.assign(Object.assign({}, compilerOptions), { target: 'es5' });
    }
    return compilerOptions;
}
function updatePackageJson(options, context, target, dependencies, packageJson) {
    const entryFileTmpl = `./${context.projectName}.<%= extension %>.js`;
    const typingsFile = path_1.relative(options.entryRoot, options.entryFile).replace(/\.[jt]sx?$/, '.d.ts');
    packageJson.main = entryFileTmpl.replace('<%= extension %>', 'umd');
    packageJson.module = entryFileTmpl.replace('<%= extension %>', 'esm');
    packageJson.typings = `./${typingsFile}`;
    devkit_1.writeJsonFile(`${options.outputPath}/package.json`, packageJson);
    if (dependencies.length > 0 &&
        options.updateBuildableProjectDepsInPackageJson) {
        buildable_libs_utils_1.updateBuildableProjectPackageJsonDependencies(context.root, context.projectName, context.targetName, context.configurationName, target, dependencies, options.buildableProjectDepsInPackageJsonType);
    }
}
function convertCopyAssetsToRollupOptions(outputPath, assets) {
    return assets
        ? assets.map((a) => ({
            src: path_1.join(a.input, a.glob).replace(/\\/g, '/'),
            dest: path_1.join(outputPath, a.output).replace(/\\/g, '/'),
        }))
        : undefined;
}
//# sourceMappingURL=package.impl.js.map