"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readCurrentProjectGraph = exports.createProjectGraph = exports.createProjectGraphAsync = exports.projectFileDataCompatAdapter = exports.projectGraphCompat4to3 = exports.projectGraphMigrate3to4 = exports.readCachedProjectGraph = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const app_root_1 = require("@nrwl/tao/src/utils/app-root");
const path_1 = require("path");
const perf_hooks_1 = require("perf_hooks");
const assert_workspace_validity_1 = require("../assert-workspace-validity");
const file_graph_1 = require("../file-graph");
const file_utils_1 = require("../file-utils");
const normalize_nx_json_1 = require("../normalize-nx-json");
const nx_deps_cache_1 = require("../nx-deps/nx-deps-cache");
const build_dependencies_1 = require("./build-dependencies");
const build_nodes_1 = require("./build-nodes");
const serverExec = require("./daemon/exec");
const server_1 = require("./daemon/server");
/**
 * Synchronously reads the latest cached copy of the workspace's ProjectGraph.
 * @throws {Error} if there is no cached ProjectGraph to read from

 * @param {string} projectGraphVersion Version to map ProjectGraph to
 * @returns {ProjectGraph}
 */
function readCachedProjectGraph(projectGraphVersion = '3.0') {
    const projectGraphCache = nx_deps_cache_1.readCache();
    if (!projectGraphCache) {
        throw new Error(`
      [readCachedProjectGraph] ERROR: No cached ProjectGraph is available.

      If you are leveraging \`readCachedProjectGraph()\` directly then you will need to refactor your usage to first ensure that
      the ProjectGraph is created by calling \`await createProjectGraphAsync()\` somewhere before attempting to read the data.

      If you encounter this error as part of running standard \`nx\` commands then please open an issue on https://github.com/nrwl/nx
    `);
    }
    let projectGraph = {
        version: projectGraphCache.version,
        nodes: projectGraphCache.nodes,
        dependencies: projectGraphCache.dependencies,
    };
    if (projectGraphVersion !== projectGraph.version) {
        projectGraph =
            projectGraphVersion === '3.0'
                ? projectGraphCompat4to3(projectGraph)
                : projectGraphMigrate3to4(projectGraph);
    }
    return projectGraph;
}
exports.readCachedProjectGraph = readCachedProjectGraph;
/**
 * Migrate project graph from v3 to v4
 * @param {ProjectGraph} projectGraph
 */
function projectGraphMigrate3to4(projectGraph) {
    const nodes = {};
    Object.entries(projectGraph.nodes).forEach(([name, node]) => {
        const files = node.data.files.map(({ file, hash, deps }) => (Object.assign({ file,
            hash }, (deps && { deps }))));
        nodes[name] = Object.assign(Object.assign({}, node), { data: Object.assign(Object.assign({}, node.data), { files }) });
    });
    return Object.assign(Object.assign({}, projectGraph), { nodes, version: '4.0' });
}
exports.projectGraphMigrate3to4 = projectGraphMigrate3to4;
/**
 * Backwards compatibility adapter for project Nodes
 * @param {ProjectGraph} projectGraph
 * @returns {ProjectGraph}
 */
function projectGraphCompat4to3(projectGraph) {
    const nodes = {};
    Object.entries(projectGraph.nodes).forEach(([name, node]) => {
        const files = node.data.files.map(({ file, hash, ext, deps }) => (Object.assign({ file,
            hash, ext: ext || path_1.extname(file) }, (deps && { deps }))));
        nodes[name] = Object.assign(Object.assign({}, node), { data: Object.assign(Object.assign({}, node.data), { files }) });
    });
    return Object.assign(Object.assign({}, projectGraph), { nodes, version: '3.0' });
}
exports.projectGraphCompat4to3 = projectGraphCompat4to3;
/**
 * Backwards compatibility adapter for FileData
 * @param {FileData} fileData
 * @param {string?} projectGraphVersion
 * @returns
 */
function projectFileDataCompatAdapter(fileData, projectGraphVersion) {
    const { file, hash, ext, deps } = fileData;
    if (projectGraphVersion !== '3.0') {
        return Object.assign({ file, hash }, { deps });
    }
    else {
        return Object.assign({ file, hash, ext: ext || path_1.extname(file) }, { deps });
    }
}
exports.projectFileDataCompatAdapter = projectFileDataCompatAdapter;
function createProjectGraphAsync(projectGraphVersion = '3.0') {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        /**
         * Using the daemon is currently an undocumented, opt-in feature while we build out its capabilities.
         * If the environment variable is not set to true, fallback to using the existing in-process logic.
         */
        if (process.env.NX_DAEMON !== 'true') {
            return createProjectGraph(undefined, undefined, undefined, projectGraphVersion);
        }
        if (!server_1.isServerAvailable()) {
            devkit_1.logger.warn('\nWARNING: You set NX_DAEMON=true but the Daemon Server is not running. Starting Daemon Server in the background...');
            yield serverExec.startInBackground();
        }
        const projectGraph = yield server_1.getProjectGraphFromServer();
        return projectGraph;
    });
}
exports.createProjectGraphAsync = createProjectGraphAsync;
function readCombinedDeps() {
    const json = devkit_1.readJsonFile(path_1.join(app_root_1.appRootPath, 'package.json'));
    return Object.assign(Object.assign({}, json.dependencies), json.devDependencies);
}
// TODO(v13): remove this deprecated function
/**
 * @deprecated This function is deprecated in favor of the new asynchronous version {@link createProjectGraphAsync}
 */
function createProjectGraph(workspaceJson, nxJson, workspaceFiles, projectGraphVersion) {
    projectGraphVersion = projectGraphVersion || '3.0';
    workspaceJson = workspaceJson || file_utils_1.readWorkspaceJson();
    nxJson = nxJson || file_utils_1.readNxJson();
    workspaceFiles = workspaceFiles || file_utils_1.readWorkspaceFiles(projectGraphVersion);
    const cacheEnabled = process.env.NX_CACHE_PROJECT_GRAPH !== 'false';
    let cache = cacheEnabled ? nx_deps_cache_1.readCache() : false;
    assert_workspace_validity_1.assertWorkspaceValidity(workspaceJson, nxJson);
    const normalizedNxJson = normalize_nx_json_1.normalizeNxJson(nxJson);
    const projectFileMap = file_graph_1.createProjectFileMap(workspaceJson, workspaceFiles);
    const packageJsonDeps = readCombinedDeps();
    const rootTsConfig = readRootTsConfig();
    let filesToProcess = projectFileMap;
    let cachedFileData = {};
    if (cache &&
        (cache.version === '3.0' || cache.version === '4.0') &&
        !nx_deps_cache_1.shouldRecomputeWholeGraph(cache, packageJsonDeps, workspaceJson, normalizedNxJson, rootTsConfig)) {
        const fromCache = nx_deps_cache_1.extractCachedFileData(projectFileMap, cache);
        filesToProcess = fromCache.filesToProcess;
        cachedFileData = fromCache.cachedFileData;
    }
    const context = createContext(workspaceJson, normalizedNxJson, projectFileMap, filesToProcess);
    let projectGraph = buildProjectGraph(context, cachedFileData, projectGraphVersion);
    if (cache && cache.version && projectGraphVersion !== cache.version) {
        projectGraph =
            projectGraphVersion === '3.0'
                ? projectGraphCompat4to3(projectGraph)
                : projectGraphMigrate3to4(projectGraph);
    }
    if (cacheEnabled) {
        nx_deps_cache_1.writeCache(packageJsonDeps, nxJson, rootTsConfig, projectGraph);
    }
    return addWorkspaceFiles(projectGraph, workspaceFiles);
}
exports.createProjectGraph = createProjectGraph;
// TODO(v13): remove this deprecated function
/**
 * @deprecated This function is deprecated in favor of {@link readCachedProjectGraph}
 */
function readCurrentProjectGraph() {
    const cache = nx_deps_cache_1.readCache();
    return cache === false ? null : cache;
}
exports.readCurrentProjectGraph = readCurrentProjectGraph;
function addWorkspaceFiles(projectGraph, allWorkspaceFiles) {
    return Object.assign(Object.assign({}, projectGraph), { allWorkspaceFiles });
}
function buildProjectGraph(ctx, cachedFileData, projectGraphVersion) {
    perf_hooks_1.performance.mark('build project graph:start');
    const builder = new devkit_1.ProjectGraphBuilder();
    build_nodes_1.buildWorkspaceProjectNodes(ctx, builder);
    build_nodes_1.buildNpmPackageNodes(builder);
    for (const proj of Object.keys(cachedFileData)) {
        for (const f of builder.graph.nodes[proj].data.files) {
            const cached = cachedFileData[proj][f.file];
            if (cached) {
                f.deps = cached.deps;
            }
        }
    }
    build_dependencies_1.buildExplicitTypeScriptDependencies(ctx, builder);
    build_dependencies_1.buildExplicitPackageJsonDependencies(ctx, builder);
    build_dependencies_1.buildImplicitProjectDependencies(ctx, builder);
    builder.setVersion(projectGraphVersion);
    const initProjectGraph = builder.getUpdatedProjectGraph();
    const r = updateProjectGraphWithPlugins(ctx, initProjectGraph);
    perf_hooks_1.performance.mark('build project graph:end');
    perf_hooks_1.performance.measure('build project graph', 'build project graph:start', 'build project graph:end');
    return r;
}
function createContext(workspaceJson, nxJson, fileMap, filesToProcess) {
    const projects = Object.keys(workspaceJson.projects).reduce((map, projectName) => {
        map[projectName] = Object.assign(Object.assign({}, workspaceJson.projects[projectName]), nxJson.projects[projectName]);
        return map;
    }, {});
    return {
        workspace: Object.assign(Object.assign(Object.assign({}, workspaceJson), nxJson), { projects }),
        fileMap,
        filesToProcess,
    };
}
function updateProjectGraphWithPlugins(context, initProjectGraph) {
    return (context.workspace.plugins || []).reduce((graph, path) => {
        try {
            const pluginPath = require.resolve(path, {
                paths: [app_root_1.appRootPath],
            });
            const pluginModule = require(pluginPath);
            if (!pluginModule.processProjectGraph) {
                return graph;
            }
            return pluginModule.processProjectGraph(graph, context);
        }
        catch (e) {
            const message = `Failed to process the project graph with "${path}". This will error in the future!`;
            if (process.env.NX_VERBOSE_LOGGING === 'true') {
                console.error(e);
                devkit_1.logger.error(message);
                return graph;
            }
            else {
                devkit_1.logger.warn(message);
                devkit_1.logger.warn(`Run with NX_VERBOSE_LOGGING=true to see the error.`);
            }
            return graph;
        }
    }, initProjectGraph);
}
function readRootTsConfig() {
    try {
        return devkit_1.readJsonFile(path_1.join(app_root_1.appRootPath, 'tsconfig.base.json'));
    }
    catch (e) {
        return devkit_1.readJsonFile(path_1.join(app_root_1.appRootPath, 'tsconfig.json'));
    }
}
//# sourceMappingURL=project-graph.js.map